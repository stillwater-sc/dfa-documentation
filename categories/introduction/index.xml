<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>introduction on Domain Flow Architecture</title><link>https://stillwater-sc.github.io/domain-flow/categories/introduction/index.html</link><description>Recent content in introduction on Domain Flow Architecture</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 15 Feb 2017 07:00:21 -0500</lastBuildDate><atom:link href="https://stillwater-sc.github.io/domain-flow/categories/introduction/index.xml" rel="self" type="application/rss+xml"/><item><title>An Example</title><link>https://stillwater-sc.github.io/domain-flow/introduction/example/index.html</link><pubDate>Wed, 15 Feb 2017 07:00:21 -0500</pubDate><guid>https://stillwater-sc.github.io/domain-flow/introduction/example/index.html</guid><description>Let&amp;rsquo;s look at an example of a simple, but frequently used operator: dense matrix multiplication. A Domain Flow program is shown below:
compute ( (i,j,k) | 1 &amp;lt;= i,j,k &amp;lt;= N ) { a: a[i,j-1,k] b: b[i-1,j,k] c: c[i,j,k-1] + a[i,j-1,k] * b[i-1,j,k] } The underlying algorithm requires a domain of computation governed by a set of constraints, and a set of computational dependencies that implicitly define a partial order across all the operations in the computation.</description></item><item><title>Parallel Programming</title><link>https://stillwater-sc.github.io/domain-flow/introduction/parallel-programming/index.html</link><pubDate>Wed, 15 Feb 2017 06:58:22 -0500</pubDate><guid>https://stillwater-sc.github.io/domain-flow/introduction/parallel-programming/index.html</guid><description>Parallel Programming To appreciate the domain flow programming model and what it enables, you need to think about the physical form a &amp;lsquo;program evaluator&amp;rsquo; could take. In the days when a processor occupied the volume of a small room, any physical computational machine was limited to a single computational element. This implied that the execution of any algorithm had to be specified as a complete order in time. At each step of the execution, the computational element would read input operands, execute an instruction, and write a result.</description></item><item><title>Spacetime</title><link>https://stillwater-sc.github.io/domain-flow/introduction/spacetime/index.html</link><pubDate>Wed, 15 Feb 2017 06:58:22 -0500</pubDate><guid>https://stillwater-sc.github.io/domain-flow/introduction/spacetime/index.html</guid><description>Constraints of Spacetime If you try to visualize the &amp;lsquo;world&amp;rsquo; from the perspective of an operand flowing through a machine, you realize that a physical machine creates a specific spatial constraint for the movement of program and data. Processing nodes are fixed in space, and information is exchanged between nodes to accomplish some transformation; we have nodes to generate operands and communication lanes between the nodes to send operands (or programs) around.</description></item><item><title>Computational Spacetime</title><link>https://stillwater-sc.github.io/domain-flow/introduction/computational-spacetime/index.html</link><pubDate>Wed, 15 Feb 2017 06:58:22 -0500</pubDate><guid>https://stillwater-sc.github.io/domain-flow/introduction/computational-spacetime/index.html</guid><description>Computational Spacetime Data movement in a parallel machine experiences the constraints of spacetime and more. The propagation delays in the communication channels act similarly as the constraint on the speed of light in spacetime. Let&amp;rsquo;s bring back the mental model of a parallel machine being a fixed graph in space with communication channels connecting a subset of nodes. The channels of communication constrain the propagation directions for information exchange. If we make the assumption that computation and communication are separate steps and that they can be overlapped to hide the latency of the communication phase, then we can leverage the mental model of spacetime to argue about partial orders of computational events that might be able to effect each other.</description></item><item><title>Domain Flow</title><link>https://stillwater-sc.github.io/domain-flow/introduction/domain-flow/index.html</link><pubDate>Wed, 15 Feb 2017 06:58:22 -0500</pubDate><guid>https://stillwater-sc.github.io/domain-flow/introduction/domain-flow/index.html</guid><description>Domain Flow Domain flow is an abstract parallel programming model that is invariant to technology changes.
An equation $c = a \oplus b$ is comprised of a computation phase, the $\oplus$, and a communication phase, the $=$.
Implementation technology will impact these phases differently, and we are seeking a programming model that is invariant to the difference. A thought experiment will shed light on the desired properties of such a model.</description></item></channel></rss>