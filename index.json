[{"uri":"https://stillwater-sc.github.io/domain-flow/blas/","title":"Basic Linear Algebra","tags":[],"description":"","content":"Chapter 3 Linear Algebra: the basics Basic Linear Algebra Subroutines are an historically significant set of functions that encapsulate the basic building blocks of a large collection of linear algebra algorithms and implementation.\nThe BLAS library has proven to be a very productive mechanism to create and disseminate highly optimized numerical libraries to a plethora of computer architectures and machines. Writing high-performance linear algebra algorithms turns out to be a tenacious problem, but since linear algebra operations are essential\ncomponents in computational methods, the investment can pay high dividends.\n"},{"uri":"https://stillwater-sc.github.io/domain-flow/linearsolvers/","title":"Linear Solvers","tags":[],"description":"","content":"Chapter 6 Linear Solvers Solving systems of equations is the impetus for the class of algorithms called linear solvers.\n"},{"uri":"https://stillwater-sc.github.io/domain-flow/factorization/","title":"Matrix Factorization","tags":[],"description":"","content":"Chapter 4 Matrix Factorization Matrix factorizations are the work horse of linear algebra applications. Factorizations create equivalences that improve the usability or robustness of an algorithm.\n"},{"uri":"https://stillwater-sc.github.io/domain-flow/matrixkernels/","title":"Matrix Kernels","tags":[],"description":"","content":"Chapter 5 Matrix Kernels Matrix Kernels are important to characterize and classify the underlying system of equations. Identifying singularity, and quantifying the null-space of a matrix are key operators before we can try to solve systems of equations.\n"},{"uri":"https://stillwater-sc.github.io/domain-flow/design/","title":"Elements of Good Design","tags":[],"description":"","content":"Chapter 2 Elements of Good Design For sixty years, we have been optimizing for sequential computation. The best algorithms for sequential execution are those that minimize the number of operations to yield results. Computational complexity theory is well-aligned with this quest, but any performance-minded algorithm designer knows that the best theoretical algorithms are not necessarily the fastest when executed on real hardware. The difference is typically caused by the trade-off sequential algorithms have to make between computation and accessing memory.\nThis chapter explores the elements of good design for parallel algorithms and their execution on real hardware.\n"},{"uri":"https://stillwater-sc.github.io/domain-flow/introduction/","title":"Introduction","tags":[],"description":"","content":"Getting Started Introduction to Domain Flow Algorithms Domain Flow algorithms are parallel algorithms that incorporate the constraints of space and time. By honoring the delay that is inherent to exchanging information between two spatially separate computation or storage sites, domain flow algorithms can improve performance and energy efficiency compared to sequential programming models that depend on (globally addressable) random access memory.\nHigh-performance, low-latency, energy-efficient computation is particularly important for the emerging application class of autonomous intelligent systems.\n"},{"uri":"https://stillwater-sc.github.io/domain-flow/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://stillwater-sc.github.io/domain-flow/","title":"Domain Flow Architecture","tags":[],"description":"","content":""},{"uri":"https://stillwater-sc.github.io/domain-flow/series/","title":"Series","tags":[],"description":"","content":""},{"uri":"https://stillwater-sc.github.io/domain-flow/tags/","title":"Tags","tags":[],"description":"","content":""}]