<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linear-schedule on Domain Flow Architecture</title><link>https://stillwater-sc.github.io/domain-flow/tags/linear-schedule/index.html</link><description>Recent content in linear-schedule on Domain Flow Architecture</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 15 Feb 2017 07:24:38 -0500</lastBuildDate><atom:link href="https://stillwater-sc.github.io/domain-flow/tags/linear-schedule/index.xml" rel="self" type="application/rss+xml"/><item><title>Linear Schedules</title><link>https://stillwater-sc.github.io/domain-flow/introduction/linearschedule/index.html</link><pubDate>Wed, 15 Feb 2017 07:24:38 -0500</pubDate><guid>https://stillwater-sc.github.io/domain-flow/introduction/linearschedule/index.html</guid><description>Linear Schedules In the previous section, we saw what the computational evolution of an unconstrained parallel algorithm looks like. However, an actual physical system would have finite resources, and certainly limited operand bandwidth.
The free schedule of a parallel algorithm tends to be unrealizable as the size of the problem grows.
Let&amp;rsquo;s go through the thought experiment what the free schedule demands from a physical system. In the free schedule animation, the propagation recurrences distributing the $A$ and $B$ matrix elements throughout the 3D lattice run &amp;lsquo;ahead&amp;rsquo; of the actual computational recurrence calculating the $C$ matrix elements.</description></item></channel></rss>