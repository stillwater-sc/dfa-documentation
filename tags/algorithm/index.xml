<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithm on Domain Flow Architecture</title><link>https://stillwater-sc.github.io/domain-flow/tags/algorithm/index.html</link><description>Recent content in algorithm on Domain Flow Architecture</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 15 Feb 2017 07:00:21 -0500</lastBuildDate><atom:link href="https://stillwater-sc.github.io/domain-flow/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>An Example</title><link>https://stillwater-sc.github.io/domain-flow/introduction/example/index.html</link><pubDate>Wed, 15 Feb 2017 07:00:21 -0500</pubDate><guid>https://stillwater-sc.github.io/domain-flow/introduction/example/index.html</guid><description>Let&amp;rsquo;s look at an example of a simple, but frequently used operator: dense matrix multiplication. A Domain Flow program is shown below:
compute ( (i,j,k) | 1 &amp;lt;= i,j,k &amp;lt;= N ) { a: a[i,j-1,k] b: b[i-1,j,k] c: c[i,j,k-1] + a[i,j-1,k] * b[i-1,j,k] } The underlying algorithm requires a domain of computation governed by a set of constraints, and a set of computational dependencies that implicitly define a partial order across all the operations in the computation.</description></item></channel></rss>