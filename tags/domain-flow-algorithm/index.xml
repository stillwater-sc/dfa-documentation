<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>domain flow algorithm on Domain Flow Architecture</title><link>https://stillwater-sc.github.io/domain-flow/tags/domain-flow-algorithm/index.html</link><description>Recent content in domain flow algorithm on Domain Flow Architecture</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 15 Feb 2017 07:24:38 -0500</lastBuildDate><atom:link href="https://stillwater-sc.github.io/domain-flow/tags/domain-flow-algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Domain Flow</title><link>https://stillwater-sc.github.io/domain-flow/introduction/domain-flow/index.html</link><pubDate>Wed, 15 Feb 2017 06:58:22 -0500</pubDate><guid>https://stillwater-sc.github.io/domain-flow/introduction/domain-flow/index.html</guid><description>Domain Flow Domain flow is an abstract parallel programming model that is invariant to technology changes.
An equation $c = a \oplus b$ is comprised of a computation phase, the $\oplus$, and a communication phase, the $=$.
Implementation technology will impact these phases differently, and we are seeking a programming model that is invariant to the difference. A thought experiment will shed light on the desired properties of such a model.</description></item><item><title>Free Schedule</title><link>https://stillwater-sc.github.io/domain-flow/introduction/freeschedule/index.html</link><pubDate>Wed, 15 Feb 2017 07:24:38 -0500</pubDate><guid>https://stillwater-sc.github.io/domain-flow/introduction/freeschedule/index.html</guid><description>We alluded to the fact that inherently-parallel algorithms exhibit some partial order, and not a total order, because the instructions that can execute independently do not have any explicit order among each other. This extra degree of freedom is another benefit domain flow algorithms exhibit over sequential algorithms. It allows the execution engine to organize any resource contention in a more energy, space, or time efficient way, as long the machine does not violate the dependency relationships specified in the algorithm.</description></item><item><title>Linear Schedules</title><link>https://stillwater-sc.github.io/domain-flow/introduction/linearschedule/index.html</link><pubDate>Wed, 15 Feb 2017 07:24:38 -0500</pubDate><guid>https://stillwater-sc.github.io/domain-flow/introduction/linearschedule/index.html</guid><description>In the previous section, we saw what the computational evolution of an unconstrained parallel algorithm looks like. However, an actual physical system would have finite resources, and certainly limited operand bandwidth.
The free schedule of a parallel algorithm tends to be unrealizable as the size of the problem grows.
Let&amp;rsquo;s go through the thought experiment what the free schedule demands from a physical system. In the free schedule animation, the propagation recurrences distributing the $A$ and $B$ matrix elements throughout the 3D lattice run &amp;lsquo;ahead&amp;rsquo; of the actual computational recurrence calculating the $C$ matrix elements.</description></item><item><title>Derivation</title><link>https://stillwater-sc.github.io/domain-flow/introduction/derivation/index.html</link><pubDate>Wed, 15 Feb 2017 07:24:38 -0500</pubDate><guid>https://stillwater-sc.github.io/domain-flow/introduction/derivation/index.html</guid><description>Remember this note?
The concepts of partial and total orders are essential for finding optimal domain flow algorithms. Poset are the source of potentially interesting solutions to high-performance, low-power execution patterns.
The Linear Algebra universe is particularly rich in partial orders, something that has been exploited for centuries. 1 Fortunately, for our discussion we can focus on the last couple of decades. The book on computing with matrices is written by Golub, and van Loan [2](#matrix computations).</description></item></channel></rss>